'use strict';

var xmldom = require('xmldom');
var react = require('react');

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









































var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * Validates a given converters input
 * @param {Object} converters - an object, with functions as values
 * @returns {boolean} - true when converters is valid, and false when it is invalid
 * @private
 */
function validateConverters(converters) {
  if ((typeof converters === 'undefined' ? 'undefined' : _typeof(converters)) !== 'object') {
    return false;
  }

  var keys = Object.keys(converters);
  var isEmpty = !keys.length;

  if (isEmpty) {
    return false;
  }

  var isFunction = function isFunction(key) {
    return typeof converters[key] === 'function';
  };
  return keys.every(isFunction);
}

/**
 * Gets map of XML node attributes of a given node.
 * @param {Object} node - XML node
 * @returns {Array} - list of children XML nodes
 * @private
 */
function getAttributes(node) {
  if (!node) {
    return {};
  }

  var attributes = node.attributes;


  if (!attributes || !attributes.length) {
    return {};
  }

  return Array.from(attributes).reduce(function (results, attr) {
    var name = attr.name,
        value = attr.value;

    results[name] = value;
    return results;
  }, {});
}

/**
 * Gets list of XML nodes which are the child of a given node.
 * @param {Object} node - XML node
 * @returns {Array} - list of children XML nodes
 * @private
 */
function getChildren(node) {
  if (!node) {
    return [];
  }

  var children = node.childNodes;


  if (!children) {
    return [];
  }

  return children.length ? Array.from(children) : [];
}

/**
 * Visit XML nodes recursively and convert into React elements.
 * @param {Object} node - xml node
 * @param {number} index - Node index to be used as the key
 * @param {Object} converters - Map of XML tag names to component generating functions
 * @param {Object} [data] - Optional data to be passed to coverters
 * @return {Object} React element
 * @private
 */
function visitNode(node, index, converters, data) {
  if (!node) {
    return null;
  }

  var tagName = node.tagName,
      nodeType = node.nodeType;

  // if this is a text node

  if (nodeType === 3) {
    return node.nodeValue;
  }

  if (!tagName) {
    return null;
  }

  var converter = converters[tagName];

  if (typeof converter !== 'function') {
    return null;
  }

  var attributes = getAttributes(node);

  var _converter = converter(attributes, data),
      type = _converter.type,
      props = _converter.props;

  var newProps = Object.assign({}, { key: index }, props);

  var children = getChildren(node);
  var childElements = children.map(function (child, childIndex) {
    return visitNode(child, childIndex, converters, data);
  });

  return react.createElement.apply(undefined, [type, newProps].concat(toConsumableArray(childElements)));
}

var ERR_INVALID_XML = 'XMLToReact: Unable to parse invalid XML input. Please input valid XML.';

var throwError = function throwError(m) {
  throw new Error(m);
};

var parser = new xmldom.DOMParser({
  errorHandler: throwError,
  fatalError: throwError,
  warning: throwError
});

/*
 * Class representing an XML to React transformer.
 * @public
 */

var XMLToReact = function () {

  /*
   * Create a XML to React converter.
   * @param {Object} converters - a mapping of tag names to a function returning the desired mapping.
   * @public
   */
  function XMLToReact(converters) {
    classCallCheck(this, XMLToReact);

    var isValid = validateConverters(converters);
    if (!isValid) {
      throw new Error(ERR_INVALID_CONVERTER);
    }

    this.converters = converters;
  }

  /*
   * Create a XML to React converter.
   * @param {string} xml - xml to convert
   * @param {Object} [data] - optional data to assist in conversion
   * @returns {Object} - React element tree
   * @public
   */


  createClass(XMLToReact, [{
    key: 'convert',
    value: function convert(xml, data) {
      if (typeof xml !== 'string') {
        return null;
      }

      var tree = void 0;

      try {
        tree = parser.parseFromString(xml, 'text/xml');
      } catch (e) {
        console.warn(ERR_INVALID_XML);
        return null;
      }

      return visitNode(tree.documentElement, 0, this.converters, data);
    }
  }]);
  return XMLToReact;
}();

module.exports = XMLToReact;
